/**
 * OpenBmclAPI (Golang Edition)
 * Copyright (C) 2024 Kevin Z <zyxkad@gmail.com>
 * All rights reserved
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package utils

import (
	"encoding/json"
	"time"

	"gopkg.in/yaml.v3"
)

var Hex256 = [256]string{
	"00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f",
	"10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f",
	"20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f",
	"30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f",
	"40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f",
	"50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f",
	"60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f",
	"70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f",
	"80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f",
	"90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f",
	"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af",
	"b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf",
	"c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf",
	"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df",
	"e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef",
	"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff",
}

const NumToHexMap = "0123456789abcdef"

var HexToNumMap = [256]int{
	'0': 0x0, '1': 0x1, '2': 0x2, '3': 0x3, '4': 0x4, '5': 0x5, '6': 0x6, '7': 0x7, '8': 0x8, '9': 0x9,
	'a': 0xa, 'b': 0xb, 'c': 0xc, 'd': 0xd, 'e': 0xe, 'f': 0xf,
}

func IsHex(s string) bool {
	if len(s) < 2 || len(s)%2 != 0 {
		return false
	}
	for i := 0; i < len(s); i++ {
		if s[i] != '0' && HexToNumMap[s[i]] == 0 {
			return false
		}
	}
	return true
}

func HexTo256(s string) (n int) {
	return HexToNumMap[s[0]]*0x10 + HexToNumMap[s[1]]
}

type RawYAML struct {
	*yaml.Node
}

var (
	_ yaml.Marshaler   = RawYAML{}
	_ yaml.Unmarshaler = (*RawYAML)(nil)
)

func (r RawYAML) MarshalYAML() (any, error) {
	return r.Node, nil
}

func (r *RawYAML) UnmarshalYAML(n *yaml.Node) (err error) {
	r.Node = n
	return nil
}

type YAMLDuration time.Duration

func (d YAMLDuration) Dur() time.Duration {
	return (time.Duration)(d)
}

func (d YAMLDuration) MarshalYAML() (any, error) {
	return (time.Duration)(d).String(), nil
}

func (d *YAMLDuration) UnmarshalYAML(n *yaml.Node) (err error) {
	var v string
	if err = n.Decode(&v); err != nil {
		return
	}
	var td time.Duration
	if td, err = time.ParseDuration(v); err != nil {
		return
	}
	*d = (YAMLDuration)(td)
	return nil
}

type EmbedJSON[T any] struct {
	V T
}

var (
	_ json.Marshaler   = EmbedJSON[any]{}
	_ json.Unmarshaler = (*EmbedJSON[any])(nil)
)

func (e EmbedJSON[T]) MarshalJSON() ([]byte, error) {
	data, err := json.Marshal(e.V)
	if err != nil {
		return nil, err
	}
	return json.Marshal((string)(data))
}

func (e *EmbedJSON[T]) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return err
	}
	return json.Unmarshal(([]byte)(str), &e.V)
}
